{% extends 'lk_base.html' %}


{% load pvl_angular %}


{% block add_to_head %}

    <!-- jqxGrid -->
    <link rel="stylesheet" href="/static/libs/jqwidgets-2.9.0/jqwidgets/styles/jqx.base.css" type="text/css" />
    <link rel="stylesheet" href="/static/libs/jqwidgets-2.9.0/jqwidgets/styles/jqx.darkblue.css" type="text/css" />
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxcore.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxdata.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxbuttons.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxscrollbar.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxmenu.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxcheckbox.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxlistbox.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxdropdownlist.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxgrid.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxgrid.sort.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxgrid.pager.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxgrid.selection.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxgrid.columnsresize.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxdata.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxgrid.edit.js"></script>
    <script type="text/javascript" src="/static/libs/jqwidgets-2.9.0/jqwidgets/jqxcombobox.js"></script>

    <!-- Ангулар-директива Баланс счетов -->
    <script src="/static/js/directive_balance.js"></script>


    <style>
        .clearfix:after {
           content: " "; /* Older browser do not support empty content */
           visibility: hidden;
           display: block;
           height: 0;
           clear: both;
        }
        .balance__cell {
            width: 100px;
            font-family: Verdana, Arial, sans-serif;
        }
        .balance__cell div {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .balance__account_block {
            border-left: 1px solid #449bca;
            border-right: 1px solid #449bca;
            border-bottom: 1px solid #449bca;
            border-top: 1px solid #449bca;
            float: left;
            width: 100px;
            margin-left: -1px;
            margin-top: -1px;
            font-family: Verdana, Arial, sans-serif;
            font-size: 13px;
            color: rgb(0, 74, 115);
        }
        .balance__account_name {
            padding-top: 4px;
            padding-right: 3px;
            padding-left: 3px;
            font-weight: bold;
            color: rgb(39, 100, 133);
            font-size: 12px;
        }
        .balance__account_sum {
            padding-bottom: 4px;
            padding-right: 3px;
            padding-left: 3px;
        }
        .balance__total{
            font-weight: bold;
        }

        /*
            По умолчанию у заголовков таблицы z-index 494 почему-то в jqxGrid установлен
            Тут мы его сбрасываем чтобы при проекруте заголовок был невидим (был под нашими fixed шапкой).
        */
        .jqx-grid-column-header {
            z-index: 1 !important;
        }

        /* Переопределяем курсор над ячейками на excel-евский */
        .jqx-grid-cell {
            cursor: url("/static/img/excel_cursor.png"), pointer;
        }

        /*
            Эти 2 стиля ставятся для ячеек если ни одной записи учета или для пустых строк под
            строками с данными. В обоих случаях курсор покажем обычный.
        */
        .jqx-grid-cleared-cell, .jqx-grid-empty-cell  {
            cursor: default;
        }

        .editedRow {
            color: rgb(248, 133, 8);
        }

        .deleteIcon {
            color: red;
            opacity: 0.2;
            cursor: pointer;
            padding-top: 2px;
            font-weight: bold;
            font-size: 15px;
            text-shadow: 0 1px 0 #fff;
        }
        .deleteIcon:hover {
            opacity: 0.8;
        }
        [disabled].deleteIcon {
            color: black;
            opacity: 0.5;
            cursor: default;
        }
        .uchRowEditIcon {
            color: green;
            opacity: 0.2;
            cursor: pointer;
            padding-top: 2px;
            font-weight: bold;
            font-size: 15px;
            text-shadow: 0 1px 0 #fff;
        }
        .uchRowEditIcon:hover {
            opacity: 0.8;
        }
    </style>

{% endblock %}
{% block uch_active %} class="active"{% endblock %}

{% block lk_content %}

    <script>

        angular.module('myNgApp').controller('AddRecordCtrl', function($scope, $element){

            // Флаг сбрасывается если сработало ограничение на внесение и больше вносить нельзя.
            // $scope.showAddUchetDialog = {{ showAddUchetDialog }};

            // Список счетов и категорий
            // для категорий длва списка - полный и согласно выбранного типа (доход расход)
            $scope.accounts = {{ accountBalanceListJson|safe }};
            $scope.categoriesNoGroupAll = {{ categoryListNoGroupJson|safe }};
            $scope.categoriesNoGroupFiltered = $scope.categoriesNoGroupAll;

            // Возвращает список категорий для показа в окне учета
            $scope.pluGetCategoriesDlgList = function(){
                return $scope.categoriesNoGroupFiltered;
            };

            $scope.acrShowError = function(errText){
                $scope.error = errText;
            };

            // Что делать при клике на кнопку OK
            $scope.acrCloseDlg = function() {

                // onModelSuccessCallback - коллбек
                // который вызывается при закрытии модального окна по кнопке ОК.
                // Обработчик успешного закрытия вызываем при клике на кнопку ВНЕСТИ
                function onModelSuccessCallback(){

                    // Валидируем данные
                    dateValRes = uuValidateDate($scope.date);
                    if (dateValRes !== true){
                        $scope.acrShowError(dateValRes);
                        return false;
                    }
                    sumValRes = uuValidateSum($scope.sum);
                    if (sumValRes !== true){
                        $scope.acrShowError(sumValRes);
                        return false;
                    }

                    // parseFloat вернет число даже для случая 55ss тогда как при передаче
                    // на сервер этого значения сервер сообщит об ошибке. Поэтому тут мы корректируем.
                    // кроме того грид ждет что число бует строкой потому форматируем как строку.
                    // Решаем сразу неск. задач.
                    // 1. Преобразуем в строку (хотя исходная итак строка)
                    // 2. Точки меняем на запятые (чтобы результат всегда был с запятыми)
                    // 3. Делаем только 2 знака после запятой.
                    // 4. Удаляем лишние символы кроме того что скушала parseFloat
                    // 5. Если тип операции - расход, то введенную сумму берем со знаком минус.
                    var origStrVal = $scope.sum;
                    var strValWithPt = String(origStrVal).replace(',', '.');
                    var floatVal = parseFloat(strValWithPt);
                    var strValCleanedPlus = String(floatVal.toFixed(2));
                    var strValCleanedMinus = String((-floatVal).toFixed(2));
                    var strValWithComma = String(strValCleanedPlus).replace('.', ',');
                    var strValWithCommaMinus = String(strValCleanedMinus).replace('.', ',');

                    // Далее просто вносим правки из полей диалога в контрол грида
                    // (при добавлении - добавляем строку, при редактировании - меняем)
                    // а уже сам грид отвественен за вызов метода синхронизации с сервером
                    // т.е. так был сделан грид...
                    if ($scope.acr_is_edit_row){

                        $('#uuGrid').jqxGrid('updaterow', $scope.acr_edited_row_grid_id, {
                            'date': $scope.date,
                            'lkud_time': $scope.lkud_time,
                            'utype': uTypeList[$scope.plu_type],
                            'sum': strValWithComma,
                            'account': $scope.account,
                            'category': $scope.category,
                            'comment': $scope.comment,
                            'serverRowId': $scope.acr_server_row_id
                        });

                    }
                    else {

                        // Добавляем строку в грид, перед этим увеличив высоту грида
                        // (чтобы избежать его собственного скроллинга)
                        // Либо 2 если это операция перевода.
                        var cur_dtm = new Date();
                        var cur_time_str = cur_dtm.getHours() + ":" + cur_dtm.getMinutes();
                        if (dlgScope.plu_type == '2'){
                            var newHeight = adjustGridHeightToNewRowsCount($('#uuGrid').jqxGrid('getrows').length + 2);
                            $('#uuGrid').jqxGrid('addrow', null, {
                                'date': dlgScope.date,
                                'lkud_time': cur_time_str,
                                'utype': uTypeList[dlgScope.plu_type],
                                'sum': strValWithCommaMinus,
                                'account': dlgScope.account,
                                'category': dlgScope.category,
                                'comment': dlgScope.comment
                            });
                            $('#uuGrid').jqxGrid('addrow', null, {
                                'date': dlgScope.date,
                                'lkud_time': cur_time_str,
                                'utype': uTypeList[dlgScope.plu_type],
                                'sum': strValWithComma,
                                'account': dlgScope.account_to,
                                'category': dlgScope.category,
                                'comment': dlgScope.comment
                            });
                        }else{
                            var newHeight = adjustGridHeightToNewRowsCount($('#uuGrid').jqxGrid('getrows').length + 1);
                            $('#uuGrid').jqxGrid('addrow', null, {
                                'date': dlgScope.date,
                                'lkud_time': cur_time_str,
                                'utype': uTypeList[dlgScope.plu_type],
                                'sum': (dlgScope.plu_type == '0') ? strValWithCommaMinus : strValWithComma,
                                'account': dlgScope.account,
                                'category': dlgScope.category,
                                'comment': dlgScope.comment
                            });
                        }

                        // Снимаем выделение (ранее имевшееся) и выделяем первый столбец у добавленной строки
                        $("#uuGrid").jqxGrid('clearselection');
                        $("#uuGrid").jqxGrid('selectcell', $("#uuGrid").jqxGrid("getrows").length-1, 'sum');

                        // Скроллинг к последнему пикселю.
                        $(window).scrollTop(1000 + newHeight);

                    }

                    // Эта пара вызовов делает grid активным (клавишы влево вправо вверх вниз начинают
                    // работать на нем). Если убрать эти вызовы то клавишы не работают пока не кликнем в грид.
                    $("#contentuuGrid").attr('tabindex', 2);
                    $("#contentuuGrid").focus();
                }

                if (onModelSuccessCallback() !== false){
                    $($element).modal('hide');
                };
            }

            // Функция вызывается извне для открытия модального окна
            // если rowdata то редактируем строку, если не передано - то добавляем новую
            $scope.arcOpenModal = function(rowdata, edited_row_grid_id){

                // true - если редачим строку, false - если добавляем в грид новую
                $scope.acr_is_edit_row = !!rowdata;
                if ($scope.acr_is_edit_row){
                    $scope.acr_edited_row_grid_id = edited_row_grid_id;
                    $scope.acr_server_row_id = rowdata.serverRowId;
                };

                // Инициализируем начальными значениями (или полями из редактируемой строки)
                if ($scope.acr_is_edit_row){
                    $scope.plu_type = converUchetTypeStrToNum(uTypeList, rowdata.utype);
                    $scope.date = rowdata.date;
                    $scope.lkud_time = rowdata.lkud_time;
                    $scope.sum = rowdata.sum;
                    $scope.account = rowdata.account;
                    $scope.account_to = rowdata.account;
                    $scope.category = rowdata.category;
                    $scope.comment = rowdata.comment;
                } else {
                    $scope.plu_type = 0;
                    $scope.date = moment().format('DD.MM.YYYY');
                    $scope.sum = '0.00';
                    $scope.account = $scope.accounts[0].name;
                    $scope.category = $scope.categoriesNoGroupAll[0].name;
                    $scope.account_to = $scope.accounts[0].name;
                    $scope.comment = '';
                }

                // Текст ошибки (неверная сумма или дата)
                $scope.error = null;

                // Обновляем представление (диалог)
                $scope.$apply();

                // Показываем
                $($element).modal('show');

                $('#sumFocused').focus();
                $('#sumFocused').select();

            }

            // При изменении значения выбранного в диалоге (расход доход перевод) - обновляем список категорий
            // выпадающий - только расходы, только доходы, только переводы
            $scope.$watch('plu_type', function(new_value, old_value){
                $scope.categoriesNoGroupFiltered = [];
                for (var i=0; i<$scope.categoriesNoGroupAll.length; ++i){
                    var cat = $scope.categoriesNoGroupAll[i];

                    if (new_value == '1'){
                        var exp_type = 'LKCM_DOHOD_RASHOD_TYPE_DOHOD';
                    }
                    else { // 1 и 2
                        var exp_type = 'LKCM_DOHOD_RASHOD_TYPE_RASHOD';
                    }
                    if (cat.lkcm_dohod_rashod_type == exp_type){
                        $scope.categoriesNoGroupFiltered.push(cat);
                    }

                }
            });
        });

    </script>

    <!-- Диалог добавления операции учета -->
    <div id="addRecordDialog" class="modal" style="display: none;" data-keyboard="true" ng-controller="AddRecordCtrl" tabindex="-1">
        <div class="modal-dialog">
        <div class="modal-content">
        <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
            <h4 style="margin: 0px;">
                <span ng-if="acr_is_edit_row">
                    Редактирование
                </span>
                <span ng-if="!acr_is_edit_row">
                    Внесение
                </span>
                операции учета
            </h4>
        </div>
        <div class="modal-body" style="padding-bottom: 0px;">

            {% ifnotequal get5DaysPaidLeft None %}
                <div class="alert alert-info">
                    Режим "Оплаченный" будет действовать сегодня и <strong>еще {{ get5DaysPaidLeft }} дней</strong>.
                    Затем потребуется произвести оплату для добавления новых операций учета.
                    Для оплаты пройдите на страницу <a href="{% url 'lk_pay_url' %}"><strong>"Оплата"</strong></a>.
                </div>
            {% endifnotequal %}

            <form class="form-horizontal" ng-enter="acrCloseDlg()">
                <div class="form-group">
                    <label class="control-label col-xs-4">Операция</label>
                    <div class="col-xs-8" class="btn-group" data-toggle="buttons-radio">
                      <button type="button" class="btn btn-default" ng-class="{active: plu_type==0}" ng-click="plu_type=0">Расход</button>
                      <button type="button" class="btn btn-default" ng-class="{active: plu_type==1}" ng-click="plu_type=1">Доход</button>
                      <button type="button" class="btn btn-default" ng-class="{active: plu_type==2}" ng-click="plu_type=2">Перевод</button>
                    </div>
                </div>
                <div class="form-group">
                    <label class="control-label col-xs-4">Дата</label>
                    <div class="col-xs-8">
                        <input class="form-control" type="text" placeholder="Дата" ng-model="date">
                    </div>
                </div>
                <div ng-switch="plu_type">
                    <div ng-switch-when="0" class="form-group">
                        <label class="control-label col-xs-4">Сумма расхода</label>
                        <div class="col-xs-8">
                            <span style="position: absolute; left: 5px; margin-left: 15px; margin-top: 6px;">–</span>
                            <span style="position: absolute; left: 105px; margin-left: 15px; margin-top: 6px;">р.</span>
                            <input class="form-control" id='sumFocused' type="text" ng-model="$parent.sum" style="padding-left: 15px; width: 96px;">
                        </div>
                    </div>
                    <div ng-switch-when="1" class="form-group">
                        <label class="control-label col-xs-4">Сумма дохода</label>
                        <div class="col-xs-8">
                            <input class="form-control" id='sumFocused' type="text" ng-model="$parent.sum" style="width: 106px;">
                            <span class="help-inline">р.</span>
                        </div>
                    </div>
                    <div ng-switch-when="2" class="form-group">
                        <label class="control-label col-xs-4">Сумма перевода</label>
                        <div class="col-xs-8">
                            <input class="form-control" id='sumFocused' type="text" ng-model="$parent.sum" style="width: 106px;">
                            <span class="help-inline">р.</span>
                        </div>
                    </div>
                </div>
                <div ng-switch="plu_type" >
                    <div ng-switch-default>
                        <div class="form-group">
                            <label class="control-label col-xs-4">Счет</label>
                            <div class="col-xs-8">
                                <select class="form-control" style="width: 310px;" ng-model="$parent.account" ng-options="a.name as a.name for a in $parent.accounts">
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="control-label col-xs-4">Категория</label>
                            <div class="col-xs-8">
                                <select class="form-control" style="width: 310px;" ng-model="$parent.category" ng-options="c.scf_name as c.scf_name for c in $parent.pluGetCategoriesDlgList()">
                                </select>
                            </div>
                        </div>
                    </div>
                    <div ng-switch-when="2">
                        <div class="form-group">
                            <label class="control-label col-xs-4">Счет откуда</label>
                            <div class="col-xs-8">
                                <select class="form-control" style="width: 310px;" ng-model="$parent.account" ng-options="a.name as a.name for a in $parent.accounts">
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="control-label col-xs-4">Счет куда</label>
                            <div class="col-xs-8">
                                <select class="form-control" style="width: 310px;" ng-model="$parent.account_to" ng-options="a.name as a.name for a in $parent.accounts">
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label class="control-label col-xs-4">Комментарий</label>
                    <div class="col-xs-8">
                        <input style="width: 310px;" type="text" class="form-control" placeholder="Комментарий" ng-model="comment">
                    </div>
                </div>
            </form>

            <div class="alert alert-error" ng-show="error">
                {% ng error %}
            </div>
        </div>
        <div class="modal-footer" style="margin-top: 0px;">
            <button ng-click="acrCloseDlg()" class="btn btn-lg btn-info pull-right">Внести (Enter)</button>
            <button href="#" class="btn btn-default pull-right" style="margin-top: 5px; margin-right: 15px;" data-dismiss="modal">Отмена (Esc)</button>
        </div>

    </div>
    </div>
    </div>

    <div >

        <script>

            // Когда на сервере ни одной записи учета, то сумма баланса приходит null
            // Тут мы преобразовываем эту величину к 0.00
            function adjustServerBalance(arr){
                for (var i=0; i<arr.length; ++i)
                {
                    if (arr[i].balance == null)
                    {
                        arr[i].balance = 0.00;
                    }
                    else {
                        arr[i].balance = parseFloat(String(arr[i].balance).replace(',', '.'));
                    }
                }
                return arr;
            }

        </script>

        <!-- Блок с ошибкой показывается если не удалось сохраниться на сервер -->
        <div id="syncErrorMessageBlock" class="alert alert-error" style="z-index: 1000; position: fixed; width: 400px; margin-right: 50%; right: -432px; top: 70px; border: 3px solid #b94a48; display: none;">
            <h4 style="display: inline;">Внимание!</h4>
            Ошибка при сохранении данных на сервер. Несохраненные строки остались отмечены рыжим цветом.
        </div>

        <!-- Блок с ошибкой показывается если не удалось удалить строку с сервера -->
        <div id="deleteErrorMessageBlock" class="alert alert-error" style="z-index: 1000; position: fixed; width: 400px; margin-right: 50%; right: -432px; top: 70px; border: 3px solid #b94a48; display: none;">
            <h4 style="display: inline;">Внимание!</h4>
            Ошибка при удалении строки с сервера. Строка не удалена. Повторите попытку позднее.
        </div>

        <script type="text/javascript">


            // Функция получает на вход данные для строки. И номер строки.
            // Если формат данных для полей "Сумма" или "Дата" не нормализован, то
            // функция сохраняет в грид нормализованные данные и вернет true.
            // Если нормализован, то вернет false.
            function checkGridDataNormalizationAndNormalize(rowdata, rowIndex){
                // Нормализация для столбца даты
                var dateOriginalValue = rowdata['date'];
                var dateNormalizedValue = dateOriginalValue;

                if (dateOriginalValue.match(/^\s*\d{0,1}\d\.\d{0,1}\d.\d{0,1}\d\s*$/)){
                    dateNormalizedValue = moment(dateOriginalValue, 'DD.MM.YY').format('DD.MM.YYYY');
                }
                else{
                    dateNormalizedValue = moment(dateOriginalValue, 'DD.MM.YYYY').format('DD.MM.YYYY');
                }

                // Если значение изменилось после нормализации - сохраним его в грид.
                // Если не делать эту проверку на изменение значения то будет рекурсия бесконечная
                // так как при установке нового значения снова вызовется текущий обработчик.
                if (dateNormalizedValue != dateOriginalValue) {
                    $("#uuGrid").jqxGrid('setcellvalue', rowIndex, 'date', dateNormalizedValue);
                    return true;
                }

                // Нормализация для столбца суммы
                var sumOriginalValue = rowdata['sum'];
                var sumNormalizedValue = sumOriginalValue;

                // Сохраняем в грид с запятой, в виде строки.
                // Хотя это не очень правильно (числа хранятся как строки и сортировка например будет
                // неправильно работать), нам это сейчас походит, потому что
                // при редактировании (когда отображается поле ввода) чтобы числа были с запятыми
                // а сортировка пока нам не нужна.
                sumNormalizedValue = parseFloat(String(sumOriginalValue).replace(',', '.')).toFixed(2);
                sumNormalizedValue = String(sumNormalizedValue).replace('.', ',');

                // Если значение изменилось после нормализации - сохраним его в грид.
                // Если не делать эту проверку на изменение значения то будет рекурсия бесконечная
                // так как при установке нового значения снова вызовется текущий обработчик.
                if (sumOriginalValue != sumNormalizedValue) {
                    $("#uuGrid").jqxGrid('setcellvalue', rowIndex, 'sum', sumNormalizedValue);
                    return true;
                }

                return false;
            }

            // Класс отвечает за хранение id удаляемых строк (запрос ушел на сервер но ответ еще не пришел ждем).
            function GridDeletedRowsServerSyncronization(){
                // В списке храним id строк которые были удалены (отправляются на сервер)
                var self = this;
                this.deletedRows = new Array();

                this.isRowDisabled = function(rowId){
                    for(var i=0; i<this.deletedRows.length; ++i){
                        if (rowId == this.deletedRows[i]){
                            return true;
                        };
                    }
                    return false;
                };

                this.markRowAsDisabled = function(rowId){
                    this.deletedRows.push(rowId);
                }

                this.removeRowAsDisabled = function(rowId){
                    var i = this.deletedRows.indexOf(rowId);
                    this.deletedRows.splice(i, 1);
                }

            }

            window.deletedRowsServerSync = new GridDeletedRowsServerSyncronization();

            // Класс отвечает за синхронизацию с сервером отредактированных строк.
            function GridEditedRowsServerSyncronization(){

                var self = this;
                self._isWaitForServerResponse = false;

                // В списке храним id строк и данные для отправки на сервер.
                this._editedRows = new Array();

                // Тут храним индекс последней записи в editedRows перед отправкой запроса на сервер.
                // Надо для очистки после синхронизации.
                this._editedRowsCountBeforeSynchronization = 0;

                // Функция возвращает true если строка rowGridId еще является несинхронизированной.
                this._isRowWasEdited = function(rowGridId) {
                    for (var i = 0; i < self._editedRows.length; i++) {
                        if (self._editedRows[i].uid == rowGridId) {
                            return "editedRow";
                        }
                    }
                }

                this._handleCounter = 0;

                // Вызывается в момент получения от сервера ответа после отправки запроса для синхронизации
                this._handleServerResponse = function(successStatus, httpErrorCode, httpSuccessData) {

                    self._handleCounter++;

                    // Синхронизация прошла успешно -
                    if (successStatus){

                        // Скрываем блок ошибки при сохранении на сервер
                        $('#syncErrorMessageBlock').hide();

                        // Обновляем источник данных - добавляем в него serverRowId (для инстертнутых в БД строк)
                        var rowsFromServer = JSON.parse(httpSuccessData).rows_json;
                        var boundrows = $('#uuGrid').jqxGrid('getboundrows');
                        for(var ri=0; ri<rowsFromServer.length; ++ri) {
                            var rid = rowsFromServer[ri].uid;
                            var brix = $('#uuGrid').jqxGrid('getrowboundindexbyid', rid);
                            boundrows[brix].serverRowId = rowsFromServer[ri].serverRowId;
                        };

                        // Стираем записи из массива которые в нем были на момент отправки запроса.
                        // Стирать важно перед тем как затем удаляем класс с выделенных строк.
                        // Потому что при удалении класса почему-то снова вызываетя рендер для строк
                        // и если мы еще не удалили индекс строк то в результате синхронизированные строки
                        // при удалении стиля снова на миг подсвечиваются и возникает мигание.
                        // Этот эффект было заметно если изменить строку 1. До получения ответа - затем изменить
                        // стркоу 2. И в момент полчения ответа по строке 1 она сначала поткухнет а потом снова
                        // загорится а потом со строкой 2 потухнет.
                        // Поэтому используем вспомогательный массив originalArray.
                        originalArray = self._editedRows.slice(0);
                        self._editedRows.splice(0, self._editedRowsCountBeforeSynchronization);

                        // Код далее удаляет класс editedRows который проставляется в ячейки строки
                        // а удаляем его чтобы снять выделние с ячеек которые синхронизировались с сервером.
                        for (var i=0; i<self._editedRowsCountBeforeSynchronization; ++i){
                            var rowGridId = originalArray[i].uid;
                            var rowGridInHtmlId = '#row' + rowGridId + 'uuGrid';
                            $('#uuGrid').find(rowGridInHtmlId).find('[role="gridcell"]').removeClass('editedRow');
                        }

                        // Сохраняем новый баланс (и таблица счетов авто-обновится)
                        var abl = adjustServerBalance(JSON.parse(httpSuccessData).accountBalanceList);
                        $scope = $('#mainScope').scope();
                        $scope.accountBalanceList2 = abl;
                        $scope.$apply();

                    } else {

                        // Показываем блок ошибки при сохранении на сервер
                        $('#syncErrorMessageBlock').show();

                    }

                    // Сбрасываем флаг что ждали ответа.
                    self._isWaitForServerResponse = false;

                    // Если есть записи для отправки (появились пока ждали ответ от сервера)
                    // то заного инициируем синхронизацию
                    if (self._editedRows.length > 0) {

                        // Если была ошибка, то следующий запрос надо послать не ранее
                        // чем через 20 секунд. Иначе они начинают слаться друг за другом
                        // непрерырвно и все с ошибкой завершаются.
                        if (successStatus){
                            self._startAsyncSynchronizationWithServer();
                        }else{
                             setTimeout(self._startAsyncSynchronizationWithServer, 20000);
                        }
                    }
                }

                // Запускает асинхронную синхронизацию.
                // Предполагается что записи в editedRows имеются на момент вызова.
                // То есть проверку на наличие элементов в editedRows (необходимость синхронизации)
                // делает вызывающая сторона.
                this._startAsyncSynchronizationWithServer = function(){

                    // Если синхронизация уже выполняется (ждем ответа от сервера), то запускать ее повторно
                    // не надо чтобы не плодить запросов. Дождемся сначала ответа а потом запустим следующую.
                    if (self._isWaitForServerResponse)
                        return;

                    // Устанавливаем флаг что пошел запрос
                    self._isWaitForServerResponse = true;

                    // Сохраняем число элементов при отправке этого запроса на сервер для синхронизации
                    this._editedRowsCountBeforeSynchronization = self._editedRows.length;

                    // Отправляем запрос и принимаем ответ
                    $.post(
                        "{% url 'ajax_save_uchet_url' %}",
                        { rows_json: JSON.stringify(
                            self._editedRows.slice(0, this._editedRowsCountBeforeSynchronization)
                        )}
                    ).done(function(data, textStatus, jqXHR){
                        self._handleServerResponse(true, 0, data);
                    }).fail(function(jqXHR, textStatus, errorThrown){
                        self._handleServerResponse(false, 0);
                    });
                }

                // Вызывается из Grid Source при измеении строки
                this.updateRowGridSourceCallback = function (rowid, rowdata, commit) {

                    // Сохраняем какая строка была изменнеа
                    self._editedRows.push( rowdata );

                    // Если тут выставить false, то реализация jqxgrid вызовет setcellvalue со старым значением
                    // после чего снова вызовается updaterow и будет бесконечная рекурсия. Так что
                    // если ставить false, то надо учесть эту особенность реализации.
                    // Пока же ставим true. Предполагая что если не удастся синхронизировать
                    // то мы просто юзеру покажем эту ошибку и уже будет не важно что данные в таблице
                    // будут несовпадать с данными на сервере.
                    commit(true);

                    // Запуск асинхронной синхронизации
                    self._startAsyncSynchronizationWithServer();
                };

                this.addRowGridSourceCallback = function (rowid, rowdata, position, commit) {
                    self.updateRowGridSourceCallback(rowid, rowdata, commit);
                }

                // Подсветка строки пока она не синхронизирована с сервером
                // Коллбек вызывается при отрисовке ячеек грида.
                this.getCellClassNameGridCallback = function (rowGridIndex, datafield, value, rowdata) {
                    rowGridId = $('#uuGrid').jqxGrid('getrowid', rowGridIndex);
                    if (self._isRowWasEdited(rowGridId)) {
                        return "editedRow";
                    }
                };
            }
            var editedRowsServerSync = new GridEditedRowsServerSyncronization();


            // Получая на вход массив что пришел от сервера - создает дата адаптер который
            // передается гриду чтобы тот отрисовался.
            function createGridDataAdapterFromServerArray(serverArray){
                var data1 = new Array();
                for(var j=0;j<serverArray.length;++j){
                    var row = {};
                    u = serverArray[j];
                    row['serverRowId'] = u['id'];
                    row['date'] = moment(u['date']).format('DD.MM.YYYY');

                    // По дефолту из БД значение времени фомратируется как ЧЧ:ММ:СС, а нам для показа в ячейке надо ЧЧ:ММ
                    row['lkud_time'] = moment(u['myum_time'], 'H:m').format('HH:mm');

                    row['utype'] = u['utype__name'];
                    row['sum'] = String(u['sum']).replace('.', ',');
                    row['account'] = u['account__name'];
                    row['category'] = u['category__scf_name'];
                    row['comment'] = u['comment'];
                    data1[j] = row;
                }
                var source =
                {
                    localdata: data1,
                    datafields:
                    [
                        { name: 'serverRowId', type: 'string'},
                        { name: 'date', type: 'string'},
                        { name: 'lkud_time', type: 'string'},
                        { name: 'utype', type: 'string'},
                        { name: 'sum', type: 'string'},
                        { name: 'account', type: 'string'},
                        { name: 'category', type: 'string'},
                        { name: 'comment', type: 'string'},
                    ],
                    datatype: "array",

                    // Подсветка строки пока она не синхроинизирована с сервером
                    // Эта функция вызывается после каждго редактирования любой ячейки.
                    updaterow: function (rowid, rowdata, commit) {

                        // Если юзер набрал дату 1.1.1, то в грид сохраним 01.01.2001
                        // Если юзер набрал сумму 34,3, то в грид сохраним 34.30
                        // Сначала, при первом вызове, мы устанавливаем в грид новые данные, нормализованные.
                        // После чего функция вызовется повторно но уже с нормализованными данными.
                        // Если нормализация уже выполнена, то checkGridDataNormalizationAndNormalize вернет
                        // false и тогда вторым шагом при второ вызове - сохраним нормализованные данные
                        // на сервер.
                        // Тут более правильно передавать не rowid а rowindex но я не нашел быстрого
                        // способа получить одно из другого и пока подойдет и rowid так что его и передаю.
                        if (!checkGridDataNormalizationAndNormalize(rowdata, rowid)) {
                            editedRowsServerSync.updateRowGridSourceCallback(rowid, rowdata, commit);
                        }
                    },
                    addrow: editedRowsServerSync.addRowGridSourceCallback

                };
                var dataAdapter = new $.jqx.dataAdapter(source);
                return dataAdapter;
            }


            angular.module('myNgApp').controller('GridCtrl', function($scope, $http){

                // Последнипе 3 дня, 30 дней
                $scope.viewPeriodSet = {{ viewPeriodSetJson | safe }};

                // Все месяца за которые есть учет.
                $scope.viewPeriodMonthSet = {{ viewPeriodMonthSetJson | safe }};

                // Хз что такое, раньше коммент был такой "Список возможных значений периодов для оторажения."
                $scope.viewPeriodCode = '{{ lku_filtered_period_id }}';

                // См. goToUchUrl, это аналог, только в контроллере
                $scope.gcGoToUchUrl = function(period){
                    goToUchUrl(period, undefined, undefined);
                }

                // Возвращает все года, что есть в массиве viewPeriodMonthSet, в виде списка строк.
                // Пример - 2013, 2014, 2015 - или пустой список.
                $scope.gcGetYears = function(){
                    res = new Array();
                    for(var i=0;i<$scope.viewPeriodMonthSet.length;++i){
                        var year_str = $scope.viewPeriodMonthSet[i][0].substr(1, 4);
                        if (res.indexOf(year_str) == -1){
                            res.push(year_str);
                        }
                    }
                    return res;
                }


                // Возвращает только те эелменты из массива viewPeriodMonthSet которые соответствуют переданному году
                $scope.gcGetMonthsForYear = function(year_str){
                    var res = $.grep($scope.viewPeriodMonthSet, function(item, index){

                        // item содержит объект вида ["m2015-02", "февраль 2015", $$hashKey: "00U"]
                        return item[0].substr(1, 4) == year_str;
                    });
                    return res;
                }

                /* Делает поиск текста в списке по значению. Названа в честь функции ВПР в Ексель. */
                {# Сравнивает переданный код. Список - это тюпл из двух. Код в первом элементе. Значение во втором. #}
                {# При совпадкнии кодов - возвращает значение. #}
                $scope.vpr = function(code, list){
                    for(var i=0;i<list.length;++i){
                        if (list[i][0] == code)
                        {
                            return list[i][1];
                        }
                    };
                    alert('Не найдено значение ' + code);
                };

                $scope.accountBalanceList2 = adjustServerBalance(JSON.parse('{{ accountBalanceListJson|escapejs }}'));

                // Считает высоту грида для числа строк. Подробности см. функцию adjustGridHeightToNewRowsCount
                window.calcGridHeightToNewRowsCount = function(newRowsCount){
                    var gh = newRowsCount * 25 + 120;

                    // Если убрать эту ветку, то в момент удаления последней строки из grida
                    // Фраза "no data display" смещается уезжает влево за край (в хроме видно этот баг).
                    if (newRowsCount == 0) {
                        return 145;
                    }

                    return gh;
                }

                // Функция изменяет высоту грида в зависимости от числа строк.
                // Вообще высота должна быть равна числу строк + пустое поле 100 пикселей.
                // Это поле нужно для того чтобы в самой нижней точке редактируемая строка
                // была не у самого плинтуса (неудобно вводить) в ближе к середине области грида.
                // newRowsCount число строк которое будет.
                // Функция вызывается перед добавлением новой строки, так что фактическое число строк
                // меньше чем то которое будет через миг под которое нам надо изменить высоту.
                // Поэтому планируемое число строк поступает в аргументе а не берется из грида.
                // Возвращает высоту грида в пикселях. Новую.
                window.adjustGridHeightToNewRowsCount = function(newRowsCount){
                    var newHeight = calcGridHeightToNewRowsCount(newRowsCount);
                    $('#uuGrid').jqxGrid({'height': newHeight});
                    return newHeight;
                }


                $(document).ready(function () {

                    // Начальные данные (согласно выбранному периоду)
                    var uchetRecords = {{ uchetRecordsJson | safe }};

                    // Справочные значения (тип записи, счет, категория)
                    // Используются также при добавлении новой записи.
                    window.uTypeList = [
                        {% for t in uTypeList %}
                            '{{ t.name }}'
                            {% if not forloop.last %}
                                ,
                            {% endif %}
                        {% endfor %}
                    ];
                    window.accountList = [
                        {% for a in accountList %}
                            '{{ a.name }}'
                            {% if not forloop.last %}
                                ,
                            {% endif %}
                        {% endfor %}
                    ];
                    window.categoryList = [
                        {% for c in categoryList %}
                            '{{ c.scf_name }}'
                            {% if not forloop.last %}
                                ,
                            {% endif %}
                        {% endfor %}
                    ];


                    // Класс икапсулирует в себе код для того чтобы выпадающий список показывался сразу при
                    // начале редактировании ячейки и скрывался сразу после выбора в нем значение.
                    // Стандартное jqxGrid поведение несколько иное: для открытия надо нажать клавишу, а для
                    // завершения редактирования надо нажать ввода. Т.е. 2 дополнительных клика.
                    function InplaceDropDown(valuesList, datafield) {
                        var self = this;
                        this.editedTypeRowInndex = -1;
                        this.nowInCloseHandler = false;
                        this.createEditor = function(row, column, editor){

                            editor.jqxDropDownList({
                                autoDropDownHeight: (valuesList.length > 12) ? false: true,
                                dropDownHeight: 300,
                                source: valuesList,
                                dropDownWidth: 275,
                                enableBrowserBoundsDetection: true
                            });
                            /* С помощью этого обработчика мы скрываем выпадающий список сразу после выбора */
                            $("#dropdownlisteditoruuGrid" + datafield).bind('close', function(event){

                                // Из endcelledit вызывается close обработчик снова поэтому
                                // тут делаем проверку. Иначе образуется рекурсия и краш при отмене выбора
                                // (клик вне области выпадающего списка).
                                if (!self.nowInCloseHandler){
                                    self.nowInCloseHandler = true;
                                    $("#uuGrid").jqxGrid('endcelledit', self.editedTypeRowInndex, datafield, false);
                                }
                                self.nowInCloseHandler = false;
                            });
                        };
                        // С помощью этого обработчика мы открываем выпадающий список сразу при начале редактирования ячейки
                        this.initEditor = function(row, column, editor){
                            /* Тут сначала делаем видимым а лишь потом открыаем */
                            /* Если не делать block то выпаюащий список не имеет координат и его отображение */
                            /* покажет его не в нужном месте у яейки а у края страницы (глюк при открытии) */
                            editor.css('display', 'block');
                            editor.jqxDropDownList('open');
                            self.editedTypeRowInndex = row;
                        }
                    };

                    var typeInplaceDropDown = new InplaceDropDown(uTypeList, 'utype');
                    var accountInplaceDropDown = new InplaceDropDown(accountList, 'account');
                    var categoryInplaceDropDown = new InplaceDropDown(categoryList, 'category');

                    // HTML по умолчанию имеет вид <div ...>Значение</div>. Заменяем в нем "значение" на другой текст.
                    // С нужным нам форматированием.
                    function replateCellHtmlOldValueWithNewValue(cellHtml, oldValue, newValue) {
                        return cellHtml.substr(0, cellHtml.length - oldValue.length - 6) + newValue + '</div>';
                    }

                    // Форматирует значение суммы в красивый вид (добавляет группы и точку меняет на ,)
                    var sumCellsRenderer = function (row, columnfield, value, defaulthtml, columnproperties) {
                        // В гриде для простоы мы храним и отображаем суммы как строки с запятой в кач. разделителя.
                        // Поэтому тут, чтобы отформатировать как денежная величина, мы сначала преобразуем ее
                        // обратно в число с плавающей точкой, из которого снова форматируем в строку...
                        // Ах, да, да, взад-вперед :-( ... Зато работает.
                        var currencyValue = parseFloat(value.replace(',', '.'));
                        var withRoubleValue = window.uuFormatCurrency(currencyValue);
                        return replateCellHtmlOldValueWithNewValue(defaulthtml, value, withRoubleValue);
                    }

                    // Выводит крестик кликая на который можно удалить строку.
                    var deleteRowCellRenderer = function (row, columnfield, value, defaulthtml, columnproperties) {
                        var id = $("#uuGrid").jqxGrid('getrowid', row);
                        var dis = "";
                        if (deletedRowsServerSync.isRowDisabled(id)){
                            dis = " disabled = 'disabled' ";
                        }
                        return replateCellHtmlOldValueWithNewValue(defaulthtml, value,
                                "<span title='Удалить' class='deleteIcon' " + dis + "uu-row-id='" + id + "'>&times;</span>");
                    }

                    // Выводит точки кликая на который можно отредачиь строку.
                    var editRowCellRenderer = function (row, columnfield, value, defaulthtml, columnproperties) {
                        var id = $("#uuGrid").jqxGrid('getrowid', row);
                        var dis = "";
                        if (deletedRowsServerSync.isRowDisabled(id)){
                            dis = " disabled = 'disabled' ";
                        }
                        return replateCellHtmlOldValueWithNewValue(defaulthtml, value,
                                "<span title='Редактировать' class='uchRowEditIcon' uu-row-id='" + id + "'>...</span>");
                    }

                    // Форматирует значение даты в красивый вид.
                    var dateCellsRenderer = function (row, columnfield, value, defaulthtml, columnproperties) {

                        // Формируем значение в зависимости от даты-времени.
                        var dt = moment(value, 'DD.MM.YYYY');
                        var newValue = dt.format("D MMM dddd");
                        return replateCellHtmlOldValueWithNewValue(defaulthtml, value, newValue);
                    }

                    // Форматирует значение время в красивый вид.
                    var lkugTimeCellsRenderer = function (row, columnfield, value, defaulthtml, columnproperties) {

                        // Формируем значение в зависимости от даты-времени.
                        var dt = moment(value, 'HH:mm:ss');
                        var newValue = dt.format("H:mm");
                        return replateCellHtmlOldValueWithNewValue(defaulthtml, value, newValue);
                    }

                    $("#uuGrid").jqxGrid({
                        theme: 'darkblue',
                        width: 1060,
                        height: calcGridHeightToNewRowsCount(uchetRecords.length),
                        selectionmode: 'multiplecellsextended',
                        editable: true,
                        columns: [
                            {
                                text: '',
                                datafield: null,
                                width: 25,
                                editable: false,
                                cellsrenderer: deleteRowCellRenderer
                            },
                            {
                                text: 'ID',
                                datafield: 'serverRowId',
                                width: 65,
                                editable: false
                            },
                            {
                                text: 'Дата',
                                datafield: 'date',
                                width: 90,
                                cellclassname: editedRowsServerSync.getCellClassNameGridCallback,
                                cellsrenderer: dateCellsRenderer,
                                validation: function (cell, value) {
                                    var valRes = uuValidateDate(value);
                                    if (valRes !== true) {
                                        return { result: false, message: valRes };
                                    }
                                    return true;
                                }
                            },
                            {
                                text: 'Время',
                                datafield: 'lkud_time',
                                width: 70,
                                cellclassname: editedRowsServerSync.getCellClassNameGridCallback,
                                // cellsrenderer: lkugTimeCellsRenderer,
                                validation: function (cell, value) {
                                    var valRes = uuValidateTime(value);
                                    if (valRes !== true) {
                                        return { result: false, message: valRes };
                                    }
                                    return true;
                                }
                            },
                            {
                                text: 'Тип',
                                datafield: 'utype',
                                width: 85,
                                cellclassname: editedRowsServerSync.getCellClassNameGridCallback,
                                columntype: 'dropdownlist',
                                createeditor: typeInplaceDropDown.createEditor,
                                initeditor: typeInplaceDropDown.initEditor
                            },
                            {
                                text: 'Сумма',
                                datafield: 'sum',
                                width: 110,
                                cellclassname: editedRowsServerSync.getCellClassNameGridCallback,
                                cellsrenderer: sumCellsRenderer,
                                cellsalign: 'right',
                                validation: function (cell, value) {
                                    var valRes = uuValidateSum(value);
                                    if (valRes !== true) {
                                        return { result: false, message: valRes };
                                    }
                                    return true;
                                }
                            },
                            {
                                text: 'Счет',
                                datafield: 'account',
                                width: 110,
                                cellclassname: editedRowsServerSync.getCellClassNameGridCallback,
                                columntype: 'dropdownlist',
                                createeditor: accountInplaceDropDown.createEditor,
                                initeditor: accountInplaceDropDown.initEditor
                            },
                            {
                                text: 'Категория',
                                datafield: 'category',
                                width: 150,
                                cellclassname: editedRowsServerSync.getCellClassNameGridCallback,
                                columntype: 'dropdownlist',
                                createeditor: categoryInplaceDropDown.createEditor,
                                initeditor: categoryInplaceDropDown.initEditor/*,
                                cellbeginedit: function(row){
                                    if (row == 5){
                                        return false;
                                    };
                                    return true;
                                }*/
                            },
                            {
                                text: 'Комментарий',
                                cellclassname: editedRowsServerSync.getCellClassNameGridCallback,
                                datafield: 'comment'
                            },
                            {
                                text: '',
                                datafield: null,
                                width: 25,
                                editable: false,
                                cellsrenderer: editRowCellRenderer
                            },
                        ]
                    });

                    // Загрузка данных.
                    $("#uuGrid").jqxGrid({source: createGridDataAdapterFromServerArray(uchetRecords)});

                    // Установка русской строки для пустого грида (вместо дефолтовой No data to display)
                    uuLocalizeJqxGrid("uuGrid");

                    // Эта пара вызовов делает grid активным (клавишы влево вправо вверх вниз начинают
                    // работать на нем). Если убрать эти вызовы то клавишы не работают пока не кликнем в грид.
                    // Выбираем ячейку самую первую
                    $("#uuGrid").jqxGrid('selectcell', $("#uuGrid").jqxGrid("getrows").length-1, 'sum');
                    $("#contentuuGrid").attr('tabindex', 2);
                    $("#contentuuGrid").focus();

                    // Отлключаем выделение текста средствами браузера.
                    // Оно путает когда работаем с гридом когда начинаем выделять несколько ячеек получается
                    // задница гридовское выделение и браузерное пересекаются.
                    $('#uuGrid').jqxGrid({ enablebrowserselection: false});

                    // При клике на "-" (к примеру при вводе расхода -5 рублей) грид не включает режим редактирования
                    // для ячейки суммы почему-то. Исправляем это поведение. Дя этого нам надо знать в каком режиме
                    // грид. И если не в режиме редактирования еще, то выполнить доп. код.
                    /*

                    Этот код закоменчен т.к. он создает другой баг: при вводе минуса в поле коммента в диалогге
                    добавления операции учета фоку с поля ввода с коммента теряется, а это еще хуже и чаще.

                    $('#uuGrid').jqxGrid({

                        handlekeyboardnavigation: function(event) {

                            // Тестируем если нажат "-" и мы не в режиме редактирования
                            // При этом не нажаты Ctrl и Alt ("Ctrl -" например отвечает за уменьшене массштаба
                            // в браузере)
                            var key = event.charCode ? event.charCode : event.keyCode ? event.keyCode : 0;
                            var minusPressed = key == 189 && !event.altKey && !event.ctrlKey;
                            var isNowInEditMode = $('.jqx-input').length != 0;
                            if (isNowInEditMode == false && minusPressed) {

                                // Включаем режим редктирования для выделенной ячейки
                                var cell = $('#uuGrid').jqxGrid('getselectedcell');
                                $("#uuGrid").jqxGrid('begincelledit', cell.rowindex, cell.datafield);

                                // Конструкция ниже помещает в очередь интерпретатора JS задание вставить минус
                                // в поле ввода и переместить курсор в конец в этом поле ввода. Если убрать setTimeout,
                                // то в поле ввода тоже вставится минус но этот минус будет выделен, то есть при нажатии
                                // любой клавишы юзером этот минус сотрется. Видимо так происходит потому что begincelledit
                                // помещает событие focus в очередь, поэтому код снизу и работает, так как помещает
                                // изменение текста после focus а не до.
                                $('.jqx-input').one('focus', function(event){
                                    setTimeout(function(){
                                        $('.jqx-input').val('');
                                        $('.jqx-input').val('-');
                                    }, 0);
                                });

                                // true сообщает в jqxGrid что использовать дефолтов обработчик НЕ надо мы обработали.
                                return true;
                            };

                            // false сообщает в jqxGrid что использовать дефолтов обработчик
                            return false;
                        }
                    });
                    */

                    // Делат шапку jqxGrid fixed (копируя слой поверх)
                    var $elem = $('.jqx-grid-header'); // Original element with attached data
                    var $elem2 = $elem.clone().appendTo($elem.parent().parent());
                    $elem2.css('position', 'fixed' );
                    $elem2.css('top', '149px' );
                    $elem2.css('z-index', '100');
                    $elem2.attr('uu-visible-header', '1');

                    // Устанавливаем обработчик на смену выделения чтобы выделенная ячейка была видима
                    $("#uuGrid").on('cellselect', function (event) {

                        // Скроллинг если ячейка выходит за рамки видимости сверху
                        var headerHeight = $('[uu-visible-header="1"]').position().top + $('[uu-visible-header="1"]').outerHeight();
                        var elemTopRelToDoc = $('#row' + event.args.rowindex + 'uuGrid').offset().top;
                        var winScroll = $(window).scrollTop();
                        var elemTopRelToWin = elemTopRelToDoc - winScroll;
                        if (elemTopRelToWin < headerHeight){
                            $(window).scrollTop($(window).scrollTop() - (headerHeight - elemTopRelToWin));
                        };

                        // Скроллинг если ячейка выходит за рамки видимости снизу
                        var footerHeight = $('#uuFooterFixed').outerHeight();
                        var footerTop = $(window).height() - footerHeight;
                        var elemBottomRelToDoc = $('#row' + event.args.rowindex + 'uuGrid').offset().top + $('#row' + event.args.rowindex + 'uuGrid').height();
                        var elemBottomRelToWin = elemTopRelToWin + $('#row' + event.args.rowindex + 'uuGrid').height();
                        if (elemBottomRelToWin > footerTop){
                            $(window).scrollTop($(window).scrollTop() + (elemBottomRelToWin - footerTop) + 1);
                        };
                    });

                    // Устанавливаем обработчик на клик удаления строки
                    $("#uuGrid").on('click', '[class = "deleteIcon"]', function (event) {

                        // На время пока запрос идет к серверу и ждем ответ выставляется атрибут disabled
                        // и тут мы его проверяем если он стоит - значит удаление этой строки уже отправлено к серверу.
                        // и мы еще не получили ответа а ждем, повторно ничего делать не надо.
                        if ($(event.target).attr('disabled') != undefined) {
                            return;
                        }

                        var rid = $(event.target).attr('uu-row-id');
                        if (confirm('Подтверждаете удаление?')) {

                            var rowData = $("#uuGrid").jqxGrid("getrowdatabyid", rid);

                            // Дисаблим
                            deletedRowsServerSync.markRowAsDisabled(rid);
                            $("[uu-row-id='" + rid + "']").attr('disabled', 'disabled');

                            // Тут забито на проверку есть ли строка на сервере или ее там еще нет.
                            // Просто шлем запрос на сервер.
                            // Отправляем запрос и принимаем ответ
                            $.post(
                                "{% url 'ajax_lk_delete_uchet_url' %}",
                                { rowForDelete: JSON.stringify(rowData) }
                            ).done(function(data, textStatus, jqXHR){

                                // Скрываем ошибку если показывалась
                                $('#deleteErrorMessageBlock').hide();

                                // Удаляем строку с клиентской таблицы
                                deletedRowsServerSync.removeRowAsDisabled(rid);
                                $("#uuGrid").jqxGrid('deleterow', rid);

                                // Уменьшаем высоту грида
                                adjustGridHeightToNewRowsCount($('#uuGrid').jqxGrid('getrows').length);

                                // Обновляем баланс на счетах согласно полученному от сервера.
                                var abl = adjustServerBalance(JSON.parse(data).accountBalanceList);
                                $scope = $('#mainScope').scope();
                                $scope.accountBalanceList2 = abl;
                                $scope.$apply();

                            }).fail(function(jqXHR, textStatus, errorThrown){

                                // Показываем удаление и разблокируем.
                                $('#deleteErrorMessageBlock').show();
                                deletedRowsServerSync.removeRowAsDisabled(rid);
                                $("[uu-row-id='" + rid + "']").removeAttr('disabled');

                            });

                        }

                    });

                    // Устанавливаем обработчик на клик рдактирование строки
                    $("#uuGrid").on('click', '[class = "uchRowEditIcon"]', function (event) {

                        var grid_row_id = $(event.target).attr('uu-row-id');

                        var rowData = $("#uuGrid").jqxGrid("getrowdatabyid", grid_row_id);

                        addUchetRecordOrEdit(rowData, grid_row_id);

                    });

                });

            });

        </script>
        <script>


            // ПЕреход на страницу учета с указанными периодом, счетом, категорией.
            // Если они не указаны (undefined), тогда взять их из УРЛ. Если в урл их нет,
            // тогда они будут undef.
            function goToUchUrl(period, acc, cat){
                return goToUchOrAnaUrl(period, acc, cat, false);
            }

        </script>

        <div id="mainScope" ng-controller="GridCtrl" ng-cloak style="position: relative; left: -100px;">

            <!-- Это просто белая плашка чтобы собой зкрывать грид когда тот скроллируется  -->
            <div style="position: fixed; background-color: white; z-index: 101; width: 1060px; top: 110px; height: 40px;">

            </div>
            <div style="margin-top: -2px; position: fixed; top: 110px; z-index: 101;">

                {# тут делается подсветка фоном если этот пункт выбран #}
                <div style="padding: 2px 5px 2px 10px; display: inline-block; {% if lku_filtered_period_id != 'last30' %}background-color: #FFDA95; border-radius: 6px;{% endif %}">
                    Отображать операции за:

                    {# Источник - http://stackoverflow.com/questions/18023493/bootstrap-3-dropdown-sub-menu-missing #}
                    <style>
                        .dropdown-submenu {
                            position:relative;
                        }
                        .dropdown-submenu>.dropdown-menu {
                            top:0;
                            left:100%;
                            margin-top:-6px;
                            margin-left:-1px;
                            -webkit-border-radius:0 6px 6px 6px;
                            -moz-border-radius:0 6px 6px 6px;
                            border-radius:0 6px 6px 6px;
                        }
                        .dropdown-submenu:hover>.dropdown-menu {
                            display:block;
                        }
                        .dropdown-submenu>a:after {
                            display:block;
                            content:" ";
                            float:right;
                            width:0;
                            height:0;
                            border-color:transparent;
                            border-style:solid;
                            border-width:5px 0 5px 5px;
                            border-left-color:#cccccc;
                            margin-top:5px;
                            margin-right:-10px;
                        }
                        .dropdown-submenu:hover>a:after {
                            border-left-color:#ffffff;
                        }
                        .dropdown-submenu.pull-left {
                            float:none;
                        }
                        .dropdown-submenu.pull-left>.dropdown-menu {
                            left:-100%;
                            margin-left:10px;
                            -webkit-border-radius:6px 0 6px 6px;
                            -moz-border-radius:6px 0 6px 6px;
                            border-radius:6px 0 6px 6px;
                        }

                        {# Без этого стиля лишний трехмерный эффект на пункте выпадающего меню с кнопки выбора периододв #}
                        .btn-group.open .dropdown-submenu .dropdown-toggle {
                            -webkit-box-shadow: unset;
                            box-shadow: unset;
                        }

                    </style>
                    <div class="btn-group">
                        <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
                            {% ng vpr(viewPeriodCode, viewPeriodSet.concat(viewPeriodMonthSet)) %}
                            <span class="caret"></span>
                        </button>
                        <ul class="dropdown-menu">
                            <li class="menu-item dropdown dropdown-submenu">
                                <li class="menu-item dropdown dropdown-submenu" ng-repeat="y in gcGetYears()">
                                    <a
                                            href="#"
                                            class="dropdown-toggle"
                                            data-toggle="dropdown"
                                            ng-style="{ 'font-weight': viewPeriodCode.substr(1, 4) == y ? 'bold' : 'normal' }">
                                        {% ng y %}
                                    </a>
                                    <ul class="dropdown-menu">
                                        <li ng-repeat="p in gcGetMonthsForYear(y)">
                                            <a
                                                    ng-click="$parent.$parent.gcGoToUchUrl(p[0])"
                                                    ng-style="{ 'font-weight': viewPeriodCode == p[0] ? 'bold' : 'normal' }"
                                                    href>
                                                {% ng p[1] %}
                                            </a>
                                        </li>
                                    </ul>
                                </li>
                                <li class="disabled" ng-if="viewPeriodMonthSet.length == 0" role="presentation">
                                    <a>Отображение по месяцам<br />станет доступно когда<br /> появятся операции учета.</a>
                                </li>
                                <li role="presentation" class="divider"></li>
                                <li
                                        style="cursor: pointer;"
                                        ng-repeat="p in viewPeriodSet">
                                    <a
                                            ng-click="$parent.gcGoToUchUrl(p[0])"
                                            ng-style="{ 'font-weight': viewPeriodCode == p[0] ? 'bold' : 'normal' }"
                                            href>
                                        {% ng p[1] %}
                                    </a>
                                </li>
                            </li>
                        </ul>
                    </div>
                </div>

                {# Счет и категория #}
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.10.0/css/bootstrap-select.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.10.0/js/bootstrap-select.min.js"></script>
                <style>

                    {# Этот стиль чтобы убрать отсуп под полями выбора счета и категории, иначе там лишний отступ #}
                    #myuu_reset_css .bootstrap-select{
                        margin-bottom: 0px;
                    }

                    {# Троеточие для длинных названий счетов и категорий #}
                    #myuu_reset_css .dropdown-menu.open{
                        width: 420px;
                    }
                    #myuu_reset_css .bootstrap-select li a {
                        width: 400px;
                        overflow-x: hidden;
                        text-overflow: ellipsis;
                    }

                    {# убираем жриность для текущего пунка меню в самом контроле (он обернут в strong ) #}
                    {# чтобы быть жирным в выпадающем списке #}
                    #myuu_reset_css .bootstrap-select button strong {
                        font-weight: normal;
                    }
                </style>
                {% include 'include_uch_drop_down_combo.html' with id="lku_acc_combo" list_to_right=False  path_part_index=2 cap="Счет:" list=accountList cur_id=lku_filtered_account_id %}
                {% include 'include_uch_drop_down_combo.html' with id="lku_cat_combo" list_to_right=True   path_part_index=3 cap="Категория:" list=categoryList cur_id=lku_filtered_category_id %}

            </div>

            <div>
                <div id='uuGrid' style="border: 0px solid grey; margin-top: 35px;"></div>
            </div>

            <div style="padding-bottom: 120px;"></div>

            <div>

                <div id="uuFooterFixed" style="position: fixed; background-color: white; z-index: 99; bottom: 0px; width: 1060px; border-top: 10px solid #449bca;">

                    <button id="btnAdd" class="btn btn-info" style='position: absolute; top: 5px; z-index: 101;'>Внести (Ins)</button>

                    <!-- Добалвение новой строки учета -->
                    <script>

                        function addUchetRecordOrEdit(rowdata, edited_row_grid_id){

                            // Показываем диалог внесения модальный
                            $('#addRecordDialog').scope().arcOpenModal(rowdata, edited_row_grid_id);

                        }

                        $(document).on('keydown', function(event){

                            // Только сравнения по which недостаточно.
                            // Если нажать Ins, то which будет 45 и charCode 0
                            // Если нажать "-", то which будет 45 и charCode 45
                            if ((event.which == 45) && (event.charCode==0)){
                                addUchetRecordOrEdit();
                            };
                        });

                        $('#btnAdd').on('click', function(){
                            addUchetRecordOrEdit();
                        });
                    </script>

                    <div style="margin-left: 150px; margin-top: 5px;">

                        <!-- Таблица со списком счетов -->
                        <uu-balance account-list="accountBalanceList2">
                        </uu-balance>

                    </div>

                </div>

            </div>

        </div>

    </div>

{% endblock %}